package main

import (
	"com.bigonelab.test/lesson3"
	"fmt"
)

/**
Java和Go都处理完全不同的壁垒。
Go的指针仅限于数组和对象，它们可以提供指向任何类型的值的指针。
Go不使用异常来显示运行时和寿命终止之类的事件，而是使用错误来显示此类事件。
Go基本上被编译为机器代码。
Java支持省略检查以处理和捕获错误。
Go提供垃圾回收，但是像Java一样，它不支持完整的GC。
Go上不允许函数重载，必须具有唯一的方法和函数名称。
Java中没有原始的无符号数字类型，这就是Java不适合进行底层编程的原因。
Java中的命名空间不告诉源文件位置。
Go提供了内置数据类型（例如map和切片），以及一些通用功能（例如复制和追加等）。
Java仅允许其中包含公共类的源文件。
Go提供了在OS线程上运行的轻量级线程例程。
Java 在最佳编程语言列表中排名第18 位，而Go排在第 8 位。
Go支持复数，因为它对此具有内置支持。
Java vs Go在多态性方面有不同的看法，Java默认情况下允许多态，而Go则不会。
Go的API完全由Google处理。
Java API由开放社区流程控制。
Java默认使用虚拟方法。
Java不允许运算符重载，这使其更轻松。
*/
/**
对方法的介绍总结有以下几点：
1、对比Java中的public/private关键字来控制对象是否可被外部访问  Go使用的是以大小写字母开头的方式来定义该问题
2、对比Java的返回值要么为void，要么为对应的数或者对象，并且只有一个返回值，GO 可返回多个对象，如果不想用可以用_屏蔽
3、对比Java的方法传值，GO的方法可选传对象值或者地址值
*/
func main() {
	//使用包中的方法
	c := lesson3.Test(1, 2)
	//lesson3.test();
	fmt.Println(c)

	//使用不占内存的_来接收返回参数
	a, _, _ := lesson3.GetData()
	_, b, _ := lesson3.GetData()
	fmt.Println(a, b)
	//引用传递和值传递
	//默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。
	/**
	对函数的参数或者返回值定义成 T 还是 *T 要考虑以下几点：
	一般的判断标准是看副本创建的成本和需求。
	如果不想变量被函数所修改，那么选择类型 T
	如果变量是一个很大的struct或者数组，副本的创建相对会影响性能，这个时候要考虑使用*T
	*/
	d := 10
	fmt.Println("D初始地址", &d)
	lesson3.TestOne(d)
	fmt.Println("D调用完的地址", &d)
	lesson3.TestTwo(&d)

}
